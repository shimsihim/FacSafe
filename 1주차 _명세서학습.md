
**ROS Tutorials**

[Tutorials — ROS 2 Documentation: Eloquent  documentation](https://docs.ros.org/en/eloquent/Tutorials.html)

# 00 - ROS
## ROS (Robot Operating System)


로봇에 들어가는 소프트웨어의 개발을 도와주는 도구이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9adb6869-dc29-46ca-a77a-e7ff372e9da7/Untitled.png)

### 메타운영체제

OS위에 설치를 하며 OS기능들을 이용하여 스케줄링, 감시, 에러처리 등을 실행하는 시스템이다. (⇒미들웨어 또는 소프트웨어 프레임워크라고 한다.)

- ROS에서 만들어 놓은 클라이언트 라이브러리를 이용해서 원하는 기능을 수행하는 Node(⇒프로그램)을 만든다.
- ROS1에서의 TCPROS/UDPROS가 ROS2로 넘어오면서 DDS로 바뀌는 것을 확인할 수 있다.
    - DDS(Data Distribution Service) 실시간 데이터 분배 미들웨어
        
        네트워크에 존재하는 통신 객체들을 자동으로 검색하고 데이터의 연관성에 따라 선택적으로 연결을 수행하여 다수의 로봇 또는 장치들을 연동하고 교체하기에 효과적이다.
        
    - ROS1에서는 TCP통신을 하는 master node가 직접 노드들을 연결해준다. ⇒ master에 문제가 생기는 경우 모든 시스템이 마비될 수 있다.
    - ROS2에서는 master가 따로 존재하지 않고 분산되어 처리된다. ⇒ master에 문제가 생기는 경우 모든 시스템이 마비될 수 있다.

### ROS1 vs ROS2

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/37a95324-502c-40d7-b324-89933bbf8441/Untitled.png)

- ROS1
    - 로보 생태계 조성과 연구에 초점. ⇒ 이상적인 통신환경에서 사용한다는 가정으로 보안문제를 생각하지 않았다.
    - 리눅스만 지원하여 다양한 플랫폼에서 사용할 수 없고 제품에 넣어 양산하기에 무리가 있다.
- ROS2
    - 다양한 언어를 지원하며 윈도우, 맥을 지원하여 양산에 적합한 소프트웨어 플랫폼이 되어가고 있다.

### ROS 용어

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b1dfcfa-189b-4900-8b8b-a24ff87c4f4f/Untitled.png)

- 노드
    
    ROS에서 최소 단위의 실행 프로세스를 가리키는 용어이다. 
    
    → 하나의 파이썬 스크립트는 하나의 노드이다. 
    
- 메시지
    
    노드끼리 데이터를 주고 받는 것을 의미한다. 노드에서 다른 노드로 정보를 전달하는 단방향, 비동기식, 연속성 통신
    
- 패키지
    
    ROS 소프트웨어의 기본 단위. 패키지는 노드, 라이브러리, 환경설정 파일들을 통합하는 최소의 빌드 단위이며, 배포 단위이다. 
    

## 예제 및 명령어 정리


### ROS 예제 실행해보기 - helloworld 메시지 publish

- 예제코드 실행하기 (설치가이드 참고. 설치 완료 후 진행)
    - 새로운 터미널 사용시마다 아래 명령어 입력하기 (배치파일 불러오기)
    
    ```
    $ call C:\dev\ros2-windows\setup.bat
    ```
    
    - 터미널 2개를 실행하고 예제 코드 실행하기
    
    ```
    $ ros2 run demo_nodes_cpp talker
    $ ros2 run demo_nodes_py listener
    ```
    

### ROS 명령어

- `$ ros2 node list`
    
    실행 중인 노드 리스트 확인
    
- `$ ros2 node info /노드명`
    
    노드 정보 확인 가능 /talker로 입력시 talker노드의 Subscribers, Publishers 등 정보 확인 가능
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/700eda31-a6fa-440a-9379-9a2348fbdb6b/Untitled.png)
    
- `$ ros2 topic list`
    
    현재 publish되고 있는 메시지 리스트를 출력
    
- `$ ros2 topic echo /토픽명`
    
    현재 publish되고 있는 메시지 리스트를 출력
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4f958fd-6178-4da9-be58-2a5fc6d02030/Untitled.png)
    

## ROS의 장점


- 노드간 메시지 통신을 사용하여 복잡한 프로그램을 나눠서 여러명이 공동 개발하는데 용이하다.
    - 하나의 스크립트(노드)에서만 인지, 판단, 제어에 대한 개발을 나눠서 개발하는 경우 스크립트를 계속 공유해가면서 작업하거나 앞단의 알고리즘 개발이 끝나야 다음 작업이 가능하고, 앞단의 알고리즘이 뒷부분의 알고리즘 성능에 영향을 주는 문제도 있다.
        
        **⇒ ROS 사용시** 노드간 주고받을 토픽과 메시지 타입만 알려주면 결과를 전송해 줄 수 있어, 기능별로 노드를 나눠서 알고리즘 개발이 가능하다. 공동작업시에도 서로 영향 X
        
    - 기능별로 노드를 만들기때문에 문제발생시 어느 노드에서 메시지가 나오지 않는지 확인하여 쉽게 문제를 파악하고 해결이 가능하다.
- 개발에 필요한 다양한 툴을 제공한다.
    - 제조사에서 ROS패키지로 제공하거나 깃허브등에 공유된 센서드라이버를 사용하면 되기 때문에 라이더, 카메라, GPS/IMU와 같은 센서데이터를 쉽게 받을 수 있다.
    - 또한 ROS에서 만들어둔 표준 메시지 타입이 있어 따로 메시지 타입을 정의해서 사용할 필요가 없다.

<br />
<br />

# 01 - ROS 메시지 통신에 대한 이해

## 메시지와 토픽


- 노드간에 데이터를 주고받을 때 사용한다. 마스터를 통해서 각 노드의 publisher와 subscriber의 정보를 공유해서 메시지를 주고받는다.
- TV에 빗대어 표현하면 32ch에서 방송 A의 9시 뉴스를 시청하는 경우
    - 시청자와 방송국은 노드 (메시지를 발생시킴)
    - 32ch은 토픽(메시지가 담긴 바구니 같은 느낌)
    - 9시 뉴스는 메시지(전달하는 내용)

⇒ 채널을 알면 누구든 메시지를 받아볼 수 있지만 다른 방송국에서 같은 채널에 동시에 방송할 수 없다. (즉, 하나의 토픽에서 발행되는 메시지를 여러 노드에서 수신이 가능하다.)

### Publisher 만들기

- publisher 노드는 메시지 송신을 위한 기능을 가진다.
- 노드 로직 순서
    - publisher 생성
        
        create_publisher 함수를 사용하며 매개 변수로 메시지 타입, 토픽, 버퍼 개수가 필요.
        
        ```python
        self.str_publisher = self.create_publisher(String, '/test', 10)
        ```
        
    - 타이머 함수 생성
        
        시간을 정해두고 주기적으로 timer_callback 함수가 실행되도록 한다.
        
        ```python
        time_period=0.1 
        self.timer = self.create_timer(time_period, self.timer_callback)
        ```
        
    - 송신할 메시지 변수 생성
        
        publisher를 만들 때 사용한 타입으로 메시지 변수를 생성한다. (여기서는 String)
        
        ```python
        self.str_msg=String()
        ```
        
    - 메시지 publish
        
        어떤 메시지를 발행시킬지 작성하고 publish 함수를 호출해서 메시지를 송신한다.
        
        ```python
        self.str_publisher.publish(self.str_msg)
        ```
        

### Subscriber만들기

- subscriber노드는 메시지 수신을 위한 기능을 가진다.
- 노드 로직 순서
    - subscriber 생성
        
        create_subscription함수를 사용, 메시지 타입, 토픽, 콜백함수, 버퍼를 매개변수로 받는다.
        
        ```python
        self.subscription = self.create_subscription(String,'/test',self.listener_callback,10)
        ```
        
    - callback 함수 생성
        
        메시지를 수신하면 호출될 함수를 작성한다. ex) 메시지를 출력해본다.
        
        ```python
        def listener_callback(self,msg):
                print('Sub: '+msg.data)
        ```
        

## 시각화 툴 - rviz2, rqt


메시지를 발행하면 토픽을 수신하여 데이터 타입에 따라 시각화를 해주는 툴이다. 

메시지, 노드, 센서 데이터를 한눈에 볼 수 있어 디버깅에 도움이 된다. 

- rviz2
    
    라이다, tf, image 등의 메시지를 3D로 시각화 해준다.
    
- rqt
    
    토픽으로 나오는 메시지를 모니터할 수 있고, 노드와 메시지의 관계를 그래프로 표현해준다. 
    
<br />
<br />


# 02 - 영상 데이터 수신하여 OpenCV라이브러리 활용하기

**참고 블로그 -> openCV 사용시 참고**

[Python OpenCV 강좌 : 제 8강 - 크기 조절](https://076923.github.io/posts/Python-opencv-8/)

## OpenCV


인텔에서 만든 오픈소스 영상처리 라이브러리로 이미지 및 영상 정보를 다룰 수 있도록 하는 유용한 도구이다. 

- 이미지의 edge검출, 흑백 변환, 이를 이용한 잡음제거, 크기 조절 등이 라이브러리 내 간단한 명령어로 실천이 가능하다.
- 색 표현 방식
    - RGB/BGR
        
        openCV는 BGR 방식을 기준으로 만들어져 있다. blue, green, red 3가지 색을 채널로 하여 색을 표현한다. → RGB랑 헷갈리지 않도록 조심.
        
    - GRAYSCALE
        
         흑백으로 이미지를 표현하는 채널 방식이다. (1개의 채널로 0~255의 값을 가짐) 다른 채널을 쓰는 이미지 array와 혼용해서 쓸 때 주의해야한다. 
        
    - HSV
        
        Hue(색조), Saturation(채도), Value(명도)로 구성, RGB에 비해 직관적이다. 
        

### 적용하기

- 설치
    
    pip 패키지명은 opencv-python 이며, import 시에는 cv2
    
    ```python
    import cv2
    import numpy as np
    ```
    
- **imread(filename, flags)** 이미지 읽기
    - cv2.IMREAD_COLOR : RGB 로 읽기 (default)
    - cv2.IMREAD_GRAYSCALE : Graysacle 로 읽기
    
    ```python
    img_bgr = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
    img_gray = cv2.imdecode(np_arr, cv2.IMREAD_GRAYSCALE)
    ```
    
- resize(src, dstSizw, fx, fy, interpolation)
    
    `입력 이미지(src)`, `절대 크기(dstSize)`, `상대 크기(fx, fy)`, `보간법(interpolation)`으로 `출력 이미지(dst)`을 생성한다.
    
    ```python
    dst = cv2.resize(src, dsize=(640, 480), interpolation=cv2.INTER_AREA)
    dst2 = cv2.resize(src, dsize=(0, 0), fx=0.3, fy=0.7, interpolation=cv2.INTER_LINEAR)
    ```